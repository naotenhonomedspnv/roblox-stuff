math.randomseed(os.time())

-- -=-=-=-=-=- [ SETTINGS ] -=-=-=-=-=- --

local enabled = true
local prefix = '$sudo '

-- [chance] = 'str'
local dots = {
	[1/4] = '̇',
	[1] = '̣'
}

local libs = {
	['infinite yield'] = loadstring(game:HttpGet('https://raw.githubusercontent.com/edgeiy/infiniteyield/master/source')),
	['dex'] = loadstring(game:HttpGet('https://raw.githubusercontent.com/LorekeeperZinnia/Dex/refs/heads/master/main.lua'))
}

local commands = {
	help = function()
		print('sudo commands: \n$sudo enable\n$sudo disable\n$sudo load <libraries/library>\n$sudo info\n$sudo help\n$sudo lua <code>')
		print('libraries are infinite yield and dex.')
		print('command arguments are separated by ","')
	end,
	info = function()
		print('activated:', enabled)
	end,
	lua = function(args)
		local _args = ''
		for _, v in ipairs(_args) do
			_args = _args .. v .. ','
		end
		local f = loadstring(_args)
		if type(f) == 'function' then
			f()
		else
			warn('error executing lua code:', f)
		end
	end,
	enable = function()
		enabled = true
	end,
	disable = function()
		enabled = false
	end,
	load = function(args)
		for _, name in ipairs(args) do
			local lib = libs[name]
			if lib then
				lib()
			else
				warn('invalid library name:', name)
			end
		end
	end
}

local replacementTable = {
    a = 'ä', A = 'Ä',
    b = 'b̈', B = 'B̈',
    c = 'c̈', C = 'C̈',
    d = 'd̈', D = 'D̈',
    e = 'ë', E = 'Ë',
    f = 'f̈', F = 'F̈',
    g = 'g̈', G = 'G̈',
    h = 'ḧ', H = 'Ḧ',
    i = 'ï', I = 'Ï',
    j = 'j̈', J = 'J̈',
    k = 'k̈', K = 'K̈',
    l = 'l̈', L = 'L̈',
    m = 'm̈', M = 'M̈',
    n = 'n̈', N = 'N̈',
    o = 'ö', O = 'Ö',
    p = 'p̈', P = 'P̈',
    q = 'q̈', Q = 'Q̈',
    r = 'r̈', R = 'R̈',
    s = 's̈', S = 'S̈',
    t = 'ẗ', T = 'T̈',
    u = 'ü', U = 'Ü',
    v = 'v̈', V = 'V̈',
    w = 'ẅ', W = 'Ẅ',
    x = 'ẍ', X = 'Ẍ',
    y = 'ÿ', Y = 'Ÿ',
    z = 'z̈', Z = 'Z̈'
}

-- -=-=-=-=-=- [ SCRIPT ] -=-=-=-=-=- --

local function randomDot()
	local choice = math.random()
    local lowest = {
        dot = '',
        chance = 1
    }
	for chance, dot in pairs(dots) do
		if choice <= chance and chance <= lowest.chance then
			if type(dot) == 'table' then
				dot = dot[math.random(1, #dot)]
			end
            lowest = {
                dot = dot,
                chance = chance
            }
		end
	end
    return lowest.dot
end

local function dotsInbetween(text)
	local result = ''
	for i = 1, #text do
		result = result .. text:sub(i, i)
		if i < #text then
			result = result .. (randomDot() or '')
		end
	end
	return result
end

local function modifyText(text)
	if #text < 1 then
		return text
	end

	text = dotsInbetween(text)
	local result = ''

	for i = 1, #text do
		local letter = text:sub(i, i)
		result = result .. (replacementTable[letter] or letter)
	end
	return result
end

local success, chatTxtBox = pcall(function()
	return game:GetService("CoreGui").ExperienceChat.appLayout.chatInputBar.Background.Container.TextContainer.TextBoxContainer.TextBox
end)

if not success then
	success, chatTxtBox = pcall(function()
		return game:GetService('Players').LocalPlayer.PlayerGui.Chat.Frame.ChatBarParentFrame.Frame.BoxFrame.Frame.ChatBar
	end)
end

if not success then
	chat:SendAsync('open dev console (f9)')
	error('[ CHAT BYPASS SCRIPT ERROR ] -> could not find the chat\'s text box. get the newest version or wait for an update.')
end

local success, chat = pcall(function()
	return game:GetService("TextChatService").TextChannels:WaitForChild('RBXGeneral')
end)

if not success then
	success, chat = pcall(function()
		return {
			SendAsync = function(_, msg)
				game:GetService("ReplicatedStorage").DefaultChatSystemChatEvents.SayMessageRequest:FireServer(msg, 'All')
			end
		}
	end)
end

if not success then
	chat:SendAsync('open dev console (f9)')
	error('[ CHAT BYPASS SCRIPT ERROR ] -> could not get message sending function. get the newest version or wait for an update.')
end

local function splitString(str, separator)
	str = str .. separator
	local result = {}
	for match in str:gmatch('([^'..separator..']+)') do
		table.insert(result, match)
	end
	return result
end

local function trimString(str)
	return str:match("^%s*(.-)%s*$")
end

local function parseArgs(args)
	local newArgs = {}
	for _, arg in ipairs(args) do
		arg = trimString(arg)
		if arg == 'true' then
			table.insert(newArgs, true)
		elseif arg == 'false' then
			table.insert(newArgs, false)
		elseif tonumber(arg) then
			table.insert(newArgs, tonumber(arg))
		else
			table.insert(newArgs, arg)
		end
	end
	return newArgs
end

if _G.Connection then
    pcall(function()
        _G.Connection:Disconnect()
    end)
end
_G.Connection = chatTxtBox.FocusLost:Connect(function(enterPressed)
    if enterPressed then
        local originalMessage = chatTxtBox.Text
        chatTxtBox.Text = ""

		if originalMessage:sub(1,#prefix) == prefix then
			local info = splitString(originalMessage:sub(#prefix+1), ' ')

			local cmdName = trimString(info[1]:lower())
			local args = ''
			for i, v in ipairs(info) do
				if i == 1 then continue end
				args = args .. v .. ' '
			end
			args = parseArgs(splitString(args, ','))

			command = commands[cmdName]
			if command then
				command(args)
			else
				warn('invalid command:', cmdName)
			end
			return
		end
        
        local modifiedMessage = originalMessage
		if enabled then
			modifiedMessage = modifyText(originalMessage)
		end 

        chat:SendAsync(modifiedMessage)
    end
end)

if not _G.messaged then
	_G.messaged = true
	chat:SendAsync('open dev console (f9)')
	warn('\n\n\tthis is a message from the chat bypass script: you can chat "$sudo (command) arg1, arg2, arg3, ..." to execute a command. do "$sudo help" for more info.\n\n')
  warn('made by gigglebobspongepants (Baconboy987890)!! lolololo')
end
